# Add ability to log in to the website

In this module we're going to add the capability for users to register and sign-in on the front-end web app with a username and password. We'll do this using ASP.NET Core Identity.

## Scaffold in ASP.NET Core Identity and Default UI
> We'll start by scaffolding the default Identity experience into the front-end web app.

### Adding Identity using Visual Studio
1. Right-mouse click on the FrontEnd project in Solution Explorer and select "Add" and then "New Scaffolded Item..."
1. Select the "Identity" category from the left-hand menu and then select "Identity" from the list and click the "Add" button
1. In the "Add Identity" dialog, click the '+' button to add a data context class. Call it `FrontEnd.Data.IdentityDbContext`.
1. In the same dialog, click the '+' button to add a user class. Call it `User`.
1. Click the "Add" button

### Adding Identity via the Command Line
**TODO**

## Organize the newly created files
> Note the new files added to the project in the "Areas/Identity" folder. We're going to clean these up a little to better match this project's conventions.

1. Open the `User.cs` file and change the namespace to `FrontEnd.Data`
1. Open the `IdentityDbContext.cs` file and remove the unsed `using` statement
1. Open the `IdentityHostingStarupt.cs` file and remove the unsed `using` statement
1. Delete the `_ValidationScriptsPartial.cshtml` file in the `/Areas/Identity/Pages` folder, as we already have one in our project's regular pages path

## Update the app to support admin users
> Identity supports simple customization of the classes representing users, and when using the default Entity Framework Core, these changes will result in automatic schema updates for storage. We can also customize the default Identity UI by just scaffolding in the pages we want to change. Let's add the ability to create an admin user.

### Customize the `User` class to support admin users
1. Open the newly created `User` class in the `/Areas/Identity/Data` folder
1. Add a `bool` property called `IsAdmin` to indicate whether the user is an admin:
    ``` c#
    public class User : IdentityUser
    {
        public bool IsAdmin { get; set; }
    }
    ```

### Generate the Entity Framework migration for our Identity schema
> Now that we've modified the Identity model, we need to create the Entity Framework migration to create the matching database schema
1. Ensure the project builds successfully
1. Open a command prompt and run the following command to create the migration: `dotnet ef migrations add CreateIdentitySchema`
1. Run the following command to create and update the database: `dotnet ef database update`

### Add the authentication middleware
> We need to ensure that the request pipeline contains the Authentication middleware before any other middleware that represents resources we want to potentially authorize, e.g. Razor Pages
1. Open the `Startup.cs` file
1. In the `Configure` method, add a call to add the Authentication middleware before the call that adds MVC:
    ``` c#
    public void Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }
        else
        {
            app.UseExceptionHandler("/Error");
            app.UseHsts();
        }

        app.UseHttpsRedirection();
        app.UseStaticFiles();

        app.UseAuthentication();

        app.UseMvc();
    }
    ```

# Adding admin section

## Add an admin policy
1. Add authorization service with an admin policy to the `ConfigureServices()` method of `Startup.cs` that requires an authenticated user with a specific user name from configuration.

    ```csharp
    services.AddAuthorization(options =>
    {
        options.AddPolicy("Admin", policy =>
        {
            policy.RequireAuthenticatedUser()
                  .RequireUserName(Configuration["admin"]);
        });
    });
   ```
1. Add an admin username to `appSettings.json`, setting it to your Twitter or Google username. Alternatively, add it as a user secret using `dotnet user-secrets`:
   ```json
   {
     "ServiceUrl": "http://localhost:[Your Backend Port Number]/",
     "Admin": "<username>",
     "Logging": {
       "IncludeScopes": false,
       "Debug": {
         "LogLevel": {
           "Default": "Warning"
         }
       },
       "Console": {
         "LogLevel": {
           "Default": "Warning"
         }
       }
     }
   }   
   ```
1. Add `Microsoft.AspNetCore.Authorization` to the list of usings in `Index.cshtml.cs`, then use the `IAuthorizationService` in the page model to determine if the current user is an administrator.

   ```csharp
     private readonly IApiClient _apiClient;
     private readonly IAuthorizationService _authzService;

     public IndexModel(IApiClient apiClient, IAuthorizationService authzService)
     {
         _apiClient = apiClient;
         _authzService = authzService;
     }

     public bool IsAdmin { get; set; }

     public async Task OnGet(int day = 0)
     {
         var authzResult = await _authzService.AuthorizeAsync(User, "Admin");
         IsAdmin = authzResult.Succeeded;

         // More stuff here
         // ...
     }
   ```
1. On the `Index` razor page, add an edit link to allow admins to edit sessions. You'll add the following code directly after the `<p>` tag that contains the session `foreach` loop:
   ```csharp
   @if (Model.IsAdmin)
   {
      <p>
         <a asp-page="/Admin/EditSession" asp-route-id="@session.ID" class="btn btn-default btn-xs">Edit</a>
      </p>
   }
   ```
1. Add a nested `Admin` folder to the `Pages` folder then add an `EditSession.cshtml` razor page and `EditSession.cshtml.cs` page model to it.

1. Next, we'll protect this `EditSession` page it with an Admin policy by making the following change to the `services.AddMvc()` call in `Startup.ConfigureServices`:

   ```csharp
   services.AddMvc()
           .AddRazorPagesOptions(options =>
           {
              options.Conventions.AuthorizeFolder("/Admin", "Admin");
           });
   ```

## Add edit session form
1. Change `EditSession.cshtml.cs` to render the session in the edit form:

   ```csharp
   public class EditSessionModel : PageModel
   {
      private readonly IApiClient _apiClient;

      public EditSessionModel(IApiClient apiClient)
      {
         _apiClient = apiClient;
      }

      public Session Session { get; set; }

      public async Task OnGetAsync(int id)
      {
         var session = await _apiClient.GetSessionAsync(id);
         Session = new Session
         {
             ID = session.ID,
             ConferenceID = session.ConferenceID,
             TrackId = session.TrackId,
             Title = session.Title,
             Abstract = session.Abstract,
             StartTime = session.StartTime,
             EndTime = session.EndTime
         };
      }
   }
   ```

1. Add the "{id}" route to the `EditSession.cshtml` form:

    ```html
    @page "{id:int}"
    @model EditSessionModel
    ```

1. Add the following edit form to `EditSession.cshtml`:

   ```html
   <form method="post" class="form-horizontal">
       <div asp-validation-summary="All" class="text-danger"></div>
       <input asp-for="Session.ID" type="hidden" />
       <input asp-for="Session.ConferenceID" type="hidden" />
       <input asp-for="Session.TrackId" type="hidden" />
       <div class="form-group">
           <label asp-for="Session.Title" class="col-md-2 control-label"></label>
           <div class="col-md-10">
               <input asp-for="Session.Title" class="form-control" />
               <span asp-validation-for="Session.Title" class="text-danger"></span>
           </div>
       </div>
       <div class="form-group">
           <label asp-for="Session.Abstract" class="col-md-2 control-label"></label>
           <div class="col-md-10">
               <textarea asp-for="Session.Abstract" class="form-control"></textarea>
               <span asp-validation-for="Session.Abstract" class="text-danger"></span>
           </div>
       </div>
       <div class="form-group">
           <label asp-for="Session.StartTime" class="col-md-2 control-label"></label>
           <div class="col-md-10">
               <input asp-for="Session.StartTime" class="form-control" />
               <span asp-validation-for="Session.StartTime" class="text-danger"></span>
           </div>
       </div>
       <div class="form-group">
           <label asp-for="Session.EndTime" class="col-md-2 control-label"></label>
           <div class="col-md-10">
               <input asp-for="Session.EndTime" class="form-control" />
               <span asp-validation-for="Session.EndTime" class="text-danger"></span>
           </div>
       </div>
       <div class="form-group">
           <div class="col-md-offset-2 col-md-10">
               <button type="submit" class="btn btn-primary">Save</button>
               <button type="submit" asp-page-handler="Delete" class="btn btn-danger">Delete</button>
           </div>
       </div>  
   </form>

   @section Scripts {
       @Html.Partial("_ValidationScriptsPartial")
   }
   ```
1. Add code to handle the `Save` and `Delete` button actions in `EditSession.cshtml.cs`:

   ```csharp
   public async Task<IActionResult> OnPostAsync()
   {
      if (!ModelState.IsValid)
      {
          return Page();
      }

      await _apiClient.PutSessionAsync(Session);

      return Page();
   }

   public async Task<IActionResult> OnPostDeleteAsync(int id)
   {
      var session = await _apiClient.GetSessionAsync(id);

      if (session != null)
      {
          await _apiClient.DeleteSessionAsync(id);
      }

      return Page();
   }
   ```

1. Add a `[BindProperty]` attribute to the `Session` property in `EditSession.cshtml.cs` to make sure properties get bound
on form posts:
   ```csharp
   [BindProperty]
   public Session Session { get; set; }
   ```

1. The form should be fully functional.

## Add success message to form post and use the [PRG](https://en.wikipedia.org/wiki/Post/Redirect/Get) pattern

1. Add a `TempData` decorated `Message` property and a `ShowMessage` property to `EditSession.cshtml.cs`:

   ```csharp
   [TempData]
   public string Message { get; set; }

   public bool ShowMessage => !string.IsNullOrEmpty(Message);
   ```

1. Set a success message in the `OnPostAsync` and `OnPostDeleteAsync` methods and change `Page()` to `RedirectToPage()`:

   ```csharp
   public async Task<IActionResult> OnPostAsync()
   {
      if (!ModelState.IsValid)
      {
          return Page();
      }
      
      Message = "Session updated successfully!";

      await _apiClient.PutSessionAsync(Session);

      return RedirectToPage();
   }

   public async Task<IActionResult> OnPostDeleteAsync(int id)
   {
      var session = await _apiClient.GetSessionAsync(id);

      if (session != null)
      {
          await _apiClient.DeleteSessionAsync(id);
      }
      
      Message = "Session deleted successfully!";

      return RedirectToPage("/Index");
   }
   ```

1. Update `EditSession.cshtml` to show the message after posting. Add the following code directly below the `<h3>` tag at the top:

   ```html
   @if (Model.ShowMessage)
   {
       <div class="alert alert-success alert-dismissible" role="alert">
           <button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">&times;</span>   </button>
           @Model.Message
       </div>
   }
   ```
## Add auth tag helper
We're currently using `if` blocks to determine whether to show the login form in the header. We can clean up this code by creating a custom [Tag Helper](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/intro).

1. Create a new folder called `TagHelpers` in the root of the *FrontEnd* project. Right-click on the folder, select *Add* / *New Item...* / *Razor Tag Helper*. Name the Tag Helper `AuthzTagHelper.cs`.
1. Modify the `HtmlTargetElement` attribute to bind to all elements with an "authz" attribute:
   ```csharp
   [HtmlTargetElement("*", Attributes = "authz")]
   ```
1. Add an additional `HtmlTargetElement` attribute to bind to all elements with an "authz-policy" attribute:
   ```csharp
   [HtmlTargetElement("*", Attributes = "authz-policy")]
   ```
1. Inject the `AuthorizationService` as shown:
   ```csharp
   private readonly IAuthorizationService _authzService;

   public AuthzTagHelper(IAuthorizationService authzService)
   {
       _authzService = authzService;
   }
   ```
1. Add the following properties which will represent the `auth` and `authz` attributes we're binding to:
   ```csharp
   [HtmlAttributeName("authz")]
   public bool RequiresAuthentication { get; set; }

   [HtmlAttributeName("authz-policy")]
   public string RequiredPolicy { get; set; } 
   ```
1. Add a `ViewContext` property:
   ```csharp
   [ViewContext]
   public ViewContext ViewContext { get; set; }
   ```
1. Mark the `ProcessAsync` method as `async`.
1. Add the following code to the `ProcessAsync` method:
   ```csharp
   public override async Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
   {
       var requiresAuth = RequiresAuthentication || !string.IsNullOrEmpty(RequiredPolicy);
       var showOutput = false;

       if (context.AllAttributes["authz"] != null && !requiresAuth && !ViewContext.HttpContext.User.Identity.IsAuthenticated)
       {
           // authz="false" & user isn't authenticated
           showOutput = true;
       }
       else if (!string.IsNullOrEmpty(RequiredPolicy))
       {
           // auth-policy="foo" & user is authorized for policy "foo"
           var authorized = false;
           var cachedResult = ViewContext.ViewData["AuthPolicy." + RequiredPolicy];
           if (cachedResult != null)
           {
               authorized = (bool)cachedResult;
           }
           else
           {
               var authResult = await _authzService.AuthorizeAsync(ViewContext.HttpContext.User, RequiredPolicy);
               authorized = authResult.Succeeded;
               ViewContext.ViewData["AuthPolicy." + RequiredPolicy] = authorized;
           }

           showOutput = authorized;
       }
       else if (requiresAuth && ViewContext.HttpContext.User.Identity.IsAuthenticated)
       {
           // auth="true" & user is authenticated
           showOutput = true;
       }

       if (!showOutput)
       {
           output.SuppressOutput();
       }
   }   
   ```
1. Register the new Tag Helper in the `_ViewImports.cshtml` file:
   ```html
   @namespace FrontEnd.Pages
   @addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
   @addTagHelper *, FrontEnd
   ```
1. We can now update the `_Layout.cshtml` method to replace the `if` block with declarative code using our new Tag Helper. Update the `<form>` in the nav section with the following code:
   ```html
	<form asp-controller="account" asp-action="logout" method="post" id="logoutForm" class="navbar-right">
		<ul class="nav navbar-nav navbar-right">
                        <li authz="true"><a>@Context.User.Identity.Name</a></li>
                        <li authz="true">
                            <button type="submit" class="btn btn-link navbar-btn navbar-link">Log out</button>
                        </li>
                        <li authz="false"><a asp-page="/Login">Log in</a></li>
		</ul>
	</form>
    ```
    
**Next**: [Session #5 - Add Agenda](5.%20Add%20personal%20agenda.md) | **Previous**: [Session #3 - Add front-end](3.%20Add%20front-end%2C%20render%20agenda%2C%20set%20up%20front-end%20models.md)
