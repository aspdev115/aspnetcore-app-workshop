# Building a SPA Front End

In this session, we'll add the code for the client application. Create a view for the conference sessions, details and speaker information.

>This example uses the SpaServices templates which combines the FrontEnd and Web API by default. In this code sample/lab, the API (BackEnd) is a separate project therefore unneeded portions of the generated code can be removed and setting the url for the API will be handled in a way more apt to a production setup.

## Creating the project

Create the new SPA application using the `dotnet` CLI in the **ConferencePlanner** folder.

```bash
dotnet new angular -n FrontEndSpa -o src/FrontEndSpa
```

Add the new project to the solution

```bash
dotnet sln add src/FrontEnd/FrontEnd.csproj
```

### Clean up

Since the API is a separate project, some initial setup and cleaning out the unnecessary files can be done.

#### Remove the Weather components

- delete the **Controllers** folder
- delete **ClientApp/src/app/fetch-data** folder
- remove all references (entire line) to **FetchDataComponent** in **ClientApp/src/app/app.module.ts**
- remove the link from the **nav-menu.component.html**

```html
<li [routerLinkActive]='["link-active"]' [routerLinkActiveOptions]='{ exact: true }'>
    <a [routerLink]='["/"]' (click)='collapse()'>
    <span class='glyphicon glyphicon-home'></span> Counter
  </a>
</li>
```

### Remove the Counter components

- delete **ClientApp/src/app/counter** folder
- remove all references (entire line) to **CounterComponent** in **ClientApp/src/app/app.module.ts**
- remove the link from the **nav-menu.component.html**

```html
<li [routerLinkActive]='["link-active"]'>
  <a [routerLink]='["/counter"]' (click)='collapse()'>
    <span class='glyphicon glyphicon-education'></span> Counter
  </a>
</li>
```


## Create and wire-up the API using an Angular Service

> We'll create a class to talk to the ASP.NET Core Web API service

### Create the model

Using the Angular CLI, create the class for the model to map the ConferenceDTO classes to TypeScript classes. Change directory to ClientApp, and create a **model.ts** using the following command.

```bash
ng g class shared/model
```

Add the following code to the file.

```javascript
  export class Track {
    trackID: number;
    conferenceID: number;
    name: string;
  }

  export class Speaker {
    id: number;
    name: string;
    bio?: any;
    webSite?: any;
    sessions?: Session[]
  }

  export class Session {
    track: Track;
    speakers: Speaker[];
    tags: any[];
    id: number;
    conferenceID: number;
    title: string;
    abstract: string;
    startTime: Date;
    endTime: Date;
    duration: string;
    trackId: number;
  }
```

### Create the data service

Create a data service to call the ASP.NET Core Web API.

```bash
ng g service shared/data
```

Update the code to the following.

```javascript
import { Injectable, Inject } from '@angular/core';
import { Headers, Http } from '@angular/http';

import 'rxjs/add/operator/toPromise';

import { Session, Speaker } from './model';

@Injectable()
export class DataService {

  private headers = new Headers({ 'Content-Type': 'application/json' });
  private sessionUrl = 'api/sessions';
  private speakerUrl = 'api/speakers';
  /**
   * init with Http
   */
  constructor(private http: Http, @Inject('BASE_URL') private baseUrl: string) { }

  getSessions(): Promise<Session[]> {
    return this.http.get(this.baseUrl + this.sessionUrl)
      .toPromise()
      .then(response => <Session[]>response.json())
      .catch(this.handleError);
  }

  getSession(id: number): Promise<Session> {
    const url = `${this.baseUrl + this.sessionUrl}/${id}`
    return this.http.get(url)
      .toPromise()
      .then(response => <Session>response.json())
      .catch(this.handleError);
  }

  getSpeaker(id: number): Promise<Speaker> {
    const url = `${this.baseUrl + this.speakerUrl}/${id}`
    return this.http.get(url)
      .toPromise()
      .then(response => <Speaker>response.json())
      .catch(this.handleError);
  }

  getSpeakers(): Promise<Speaker[]> {
    return this.http.get(this.baseUrl + this.speakerUrl)
      .toPromise()
      .then(response => <Speaker[]>response.json())
      .catch(this.handleError);
  }

  private getData(response: Response) { }
  private handleError(error: any): Promise<any> {
    console.error('An error occurred', error); // for demo purposes only
    return Promise.reject(error.message || error);
  }
}
```